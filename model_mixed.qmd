---
title: "Mixed Model"
format: html
---

```{r}
#| warning: false
#| echo: false
source('functions.R')
```

To determine the normal return we can adopt a mixed model 
## Model Summary

```{r}
#| warning: false

#install.packages("broom.mixed")
library(broom.mixed)
library(lme4)
library(gt)
data <- get_model_data() |> drop_na(UBPRE524.diff)|> mutate(Qtr = quarter(Quarter), Year = year(Quarter))

estimation_data <- data |> filter(is.na(Partnership)) |> fill_gaps()
observation_data <- data |> filter(!is.na(Partnership))


# lmer1_formula <- "value_diff  ~ Qtr + RRSFS.Pop + RRSFS.Pop.lag1 + (1 | IDRSSD)"
# lmer2_formula <- "value_diff  ~ Qtr + RRSFS.Pop + RRSFS.Pop.lag1 + UNRATE + UNRATE.lag1 + (1 | IDRSSD)"
# lmer3_formula <- "value_diff  ~ Qtr + RRSFS.Pop + RRSFS.Pop.lag1 + UNRATE + UNRATE.lag1 + (1 | BankType/IDRSSD)"
lmer4_formula <- "UBPRE524.diff  ~ (1 + Year + Qtr | BankType/BankName) + UBPRE524.group.pct_change + UBPRE524.all.pct_change + RRSFS.Pop.pct_change + RRSFS.Pop.pct_change.lag1 + UBPRB538.pct_change + UBPRE263.pct_change + UNRATE.pct_change + UNRATE.pct_change.lag1"
# lmer5_formula <- "value_diff  ~ Qtr + value_diff.group.mean + (1 | IDRSSD)"
# lmer6_formula <- "value_diff  ~ Qtr + value_diff.group.mean + (1 | BankType)"
# lmer7_formula <- "value_diff  ~ Qtr + value_diff.median + (1 | BankType)"
# lmer8_formula <- "value_diff  ~ Qtr + value_diff.group.mean + (1 | IDRSSD) + RRSFS.Pop + RRSFS.Pop.lag1"
# lmer9_formula <- "value_diff.detrend  ~ RRSFS.Pop + RRSFS.Pop.lag1 + UNRATE + UNRATE.lag1 + (1 | IDRSSD)"

best_model <- lmer(as.formula(lmer4_formula), data = estimation_data)
summary(best_model)

install.packages("glmnet")
library(glmnet)
?glmnet

```


```{r}
#| warning: false
#| label: fig-plot-fit
#| fig-cap: "Fitted vs. Observed for estimation data on sub-set of firms"

augmented_data <- best_model |> broom::augment() |> mutate(Quarter = yearquarter(paste0(Year," Q", Qtr))) |> as_tsibble(index = Quarter, key = c(BankType,BankName))

augmented_data |> filter(BankName %in% unique(observation_data$BankName)) |>
        autoplot(UBPRE524.diff, colour = "darkgrey") + 
        geom_line(aes(y = .fitted, colour = "#D55E00")) + facet_wrap(~BankName+BankType, ncol = 2) +
        labs(title = "<span style='color:#D55E00'>Fitted</span> vs. <span style='color:darkgrey'>Observed</span>") +
        theme(legend.position = "none", plot.title = element_markdown(),plot.subtitle = element_markdown())

```


### Visual Checks

```{r}
#| warning: false
#| label: fig-fit
#| fig-cap: "Linear regression model diagnostics"
#| layout-ncol: 3
#| fig-subcap:
#|   - "Residuals vs Fitted - The red line is not flat suggesting we need to add additional interaction terms to better capture the relationship between the predictors and the response variable"
#|   - "Q-Q Residuals - the S shape indicates residuals have heavier tails than expected normal distribution"
#|   - "Scale-Location - slight funnel shape indicates heteroscedasticity i.e. violates linear assumption of equal variance"

#values are autocorrelated. If the p-value > 0.05 (good), this implies that the residuals of the data are are independent.
#augmented_data |> features(.innov, ljung_box) |> filter(lb_pvalue <= 0.05)
plot(best_model)
hist(resid(best_model))

install.packages("sjPlot")
library(sjPlot)
sjPlot::plot_model(best_model)
sjPlot:: tab_model(best_model)

augmented_data|> 
  ggplot(aes(x =.fitted, y = UBPRE524.diff )) +
  geom_point() +
        labs(y = "Data (actual values)",
             x = "Fitted (predicted values)" ) +
        theme(legend.position = "none", plot.title = element_markdown(),plot.subtitle = element_markdown())+
  geom_abline(intercept = 0,colour="red")

```

### Cross-Validation

```{r}
#| warning: false
#m_table |> filter(grepl("BARCLAYS",BankName)) |> select(tslm) |> gg_tsresiduals()

#A portmanteau test returns a large p-value, also suggesting that the residuals are white noise.
augment(m_table) |>
  filter(grepl("BARCLAYS",BankName))  |>
  features(.innov, ljung_box)  

bar_est_data <- estimation_data |> filter(grepl("BARCLAYS",BankName))
bar_event_data <- observation_data |> filter(grepl("BARCLAYS",BankName))
bar_data <- bar_est_data |> filter(!is.na(UBPRE524.diff)) |> add_row(bar_event_data)
bar_model <- m_table |> filter(grepl("BARCLAYS",BankName)) |> select(tslm)

m_table |>
    filter(grepl("BARCLAYS",BankName))  |>
    forecast(new_data=bar_event_data) |>
    filter(.model=='tslm') |> 
    autoplot(bar_data, colour = "pink")  + 
    geom_line(aes(x = Quarter, y=UBPRE524.diff), data= bar_event_data)

bar_est_data_tr <- bar_est_data |>
                    stretch_tsibble(.init = 3, .step = 1) |>
                    relocate( .id)

# TSCV accuracy
bar_est_data_tr |>
  model(TSLM(as.formula(market_formula))) |>
  forecast(new_data = bar_est_data_tr |> select(UBPRE524.group.diff)) |>
  fabletools::accuracy(bar_est_data)
  
# Training set accuracy
bar_est_data |>
  model(TSLM(as.formula(market_formula))) |>
  fabletools::accuracy()

estimation_data_tr <- estimation_data |>
                      stretch_tsibble(.init = 3, .step = 1) |>
                      relocate( .id)

estimation_data_tr |>
  model(TSLM(as.formula(market_formula))) |>
  forecast(new_data = estimation_data_tr |> select(UBPRE524.group.diff)) |>
  fabletools::accuracy(estimation_data)

# selected_model <- m_table |> filter(grepl("BARCLAYS",BankName))
# fabletools::glance(selected_model) |> arrange(selected_model) |> select(.model:BIC)

# bar_est_data |> 
#        run_timeseries_cv(selected_model$tslm)

  
```
